### 概述

注：回调函数在面试中被问道过有两三次了。回答的都不是很好，专门来收集整理下回调函数的相关内容。

基本概念：

函数可以作为另一个函数的参数来传递。

回调函数

主函数

中间函数

解读：

被某个函数调用的函数就叫回调。

本质：我们知道要执行什么，但是不清楚什么时候去执行，只有某个具体的模块A知道，此时就可以讲我们所知道的封装成回调函数告诉模块A。

根据上述:

我们编写一个回调函数，但是函数的调用方是模块A。模块A会在合适的时间调用我们所编写的回调函数。

因此回调函数就是事件驱动型编程。

### 回调的两种类型：

区分在于回调函数被调用的时机。

涉及到同步和异步的概念。

#### 同步回调：

讲函数A以参数的形式传入回调函数后，在函数A返回之前回调函数会被执行，也就是说我们的主程序在等待回调函数执行完成，即同步回调。

例子：

```
有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。。
```

以上旅馆是函数，旅客是参数，叫醒方式是回调函数。

举例：

```
C++中的sort函数的第三个参数，可以传入一个自定义的比较函数，根据传入参数可以实现自定义的比较，此时该函数就称为回调函数。
```

总结：

同步回调比较好理解，就是主函数的传入参数里有另外一个函数（辅助函数），根据主函数的不同的要求，我们可以实现出传入不同的辅助函数。

以sort函数为例，可以是使得某个数组从小到大，也可以使某个数组从大到小。

优点：

实现不同场景下不同的调用。



#### 异步回调：

在常规模式下，函数A和函数B都是服务调用方来执行，也就是顺序执行的操作，在回调情况下，我们自己执行和函数A，然后等完成后再去执行函数B。

异步调用这中方式更加适合高并发的场景。

异步回调本质就是事件驱动编程。

## 读事件的回调过程

### 回调函数的注册

每个文件描述符 fd有一个channel（通道），一个通道有四个回调函数指针成员。

每个通道有自己的handleevent函数。当发生事件时，通道注册的相应的回调函数就可以执行。

#### 注册回调函数的声明

![image-20210903150814077](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210903150814077.png)

#### 注册回调函数的使用

![image-20210903145511972](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210903145511972.png)

设置读事件时执行handleread（）函数。

### 关注指定的事件，等待事件触发

![image-20210903145915941](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210903145915941.png)

eventloop在构造函数里，在注册了回调函数之后，会设置读回调函数enableReading函数注册并关注可读事件。。

在最底层是通过epollpoller::updata（）函数里通过epoll_ctl函数操纵红黑树注册、修改、删除事件。

![image-20210903152423251](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210903152423251.png)

通过上述的ebent.data.ptr=channel。

就可以设置当channel上关注的事件发生时，epoll能够通过ptr指针把该时间对应的通道返回，我们就可以知道是那个通道发生的事件，从而回调这个通道上注册的相应的回调函数。

### 回调函数的调用

1.当事件发生时，epoll内部会调用fillactiveChannels函数，把发生事件的通道指针添加到存放通道指针的vector容器activechannels里。最终都会存放在eventloop的数据成员activechannels_中。

2.在loop（）函数中会遍历每一个通道，执行通道的handleevent函数，其又执行handleeventwithguard函数，在内部依据具体发生的事件进行相应的处理函数。