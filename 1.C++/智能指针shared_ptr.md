## 概述

```
shared_ptr 是C++11提供的一种智能指针类，它足够智能，可以在任何地方都不使用时自动删除相关指针，从而帮助彻底消除内存泄漏和悬空指针的问题。
它遵循共享所有权的概念，即不同的 shared_ptr 对象可以与相同的指针相关联，并在内部使用引用计数机制来实现这一点。
每个 shared_ptr 对象在内部指向两个内存位置：
1、指向对象的指针。
2、用于控制引用计数数据的指针。
共享所有权如何在参考计数的帮助下工作：
1、当新的 shared_ptr 对象与指针关联时，则在其构造函数中，将与此指针关联的引用计数增加1。
2、当任何 shared_ptr 对象超出作用域时，则在其析构函数中，它将关联指针的引用计数减1。如果引用计数变为0，则表示没有其他 shared_ptr 对象与此内存关联，在这种情况下，它使用delete函数删除该内存。

```

## 功能

```
1.C++开发处理内存泄漏最有效的办法就是使用智能指针。
2.智能指针是指向动态分配(堆)对象指针，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。它的一种通用实现技术是使用引用计数。每次使用它，内部的引用计数加1，每次析构一次，内部引用计数减1，减为0时，删除所指向的堆内存。
```

## 实现

```
当 shared_ptr内部的引用计数为零时，会自动调用所指对象的析构函数来释放内存。。
所以需要把析构函数编程public：
```



## 创建 shared_ptr 对象

### 使用原始指针创建 shared_ptr 对象

```
std::shared_ptr<int> p1(new int());
1上面这行代码在堆上创建了两块内存：1：存储int。2：用于引用计数的内存，管理附加此内存的 shared_ptr 对象的计数，最初计数将为1。
检查 shared_ptr 对象的引用计数
```

### 创建空的 shared_ptr 对象

```
因为带有参数的 shared_ptr 构造函数是 explicit 类型的，所以不能像这样std::shared_ptr<int> p1 = new int();隐式调用它构造函数。创建新的shared_ptr对象的最佳方法是使用std :: make_shared：
```

```
std::shared_ptr<int> p1 = std::make_shared<int>();
```

```
std::make_shared 一次性为int对象和用于引用计数的数据都分配了内存，而new操作符只是为int分配了内存。
```

实例