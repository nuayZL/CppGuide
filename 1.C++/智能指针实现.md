### 引言

```
C++没有垃圾回收机制、对于动态内存的分配使用和释放应该十分注意、很容易引起悬空指针和内存泄露问题。。
```

```
实现垃圾回收机制可能回破坏C++的高性能的特性。。
```

```
#include "stdafx.h"
#include<iostream>
using namespace std;
//引用计数类
class counter
{
public:
	counter(){}
	counter(int parCount) :count(parCount){}
	void increaseCount() { count++; }
	void decreasCount(){ count--; }
	int  getCount(){ return count; }
private:
	int count;
};
 
//智能指针
template<class T>
class SmartPointer
{
public:
	explicit  SmartPointer(T* pT) :mPtr(pT), pCounter(new counter(1)){}  //防止隐性转换
	explicit  SmartPointer():mPtr(NULL),pCounter(NULL){}  //构造函数2
	~SmartPointer()		         //析构函数，在引用计数为0时，释放原指针内存
	{
		if (pCounter != NULL)
		{
			pCounter->decreasCount();
			if (pCounter->getCount() == 0)
			{
				delete pCounter;
				delete mPtr;
				pCounter = NULL;	//将pCounter赋值为NULL,防止悬垂指针
				mPtr = NULL;
				cout << "delete original pointer" << endl;
			}
		}
	}
 
	SmartPointer(SmartPointer<T> &rh)	//拷贝构造函数，引用加1
	{
		this->mPtr=rh.mPtr;
		this->pCounter = rh.pCounter;
		this->pCounter->increaseCount();
	}
 
	SmartPointer<T>& operator=(SmartPointer<T> &rh) //赋值操作符，引用加1
	{
		if (this->mPtr == rh.mPtr)
			return *this;
		this->mPtr = rh.mPtr;
		this->pCounter = rh.pCounter;
		this->pCounter->increaseCount();
		return *this;
	}
	T& operator*()			//重载*操作符
	{
		return *mPtr;
	}
	
	T* operator->()			//重载->操作符
	{
		return p;
	}
	T* get()
	{
		return mPtr;
	}
private:
	T* mPtr;
	counter* pCounter;
};
int _tmain(int argc, _TCHAR* argv[])
{
	SmartPointer<int> sp1(new int(10));
	SmartPointer<int> sp2 = sp1;
	SmartPointer<int> sp3;
	sp3 = sp2;
	return 0;
}
```

