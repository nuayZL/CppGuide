## 定时器存在的意义

```
定期检测客户连接的活动状态
如果一个连接超过一定时间没有读写操作，就将其关闭。。即关闭非活动连接
**每个连接占用一个文件描述符
管理定时事件，使在预期时间触发并不影响服务器的主要逻辑
```

## 定时器结构体（对象）

```
struct TimerNode {
    int id;                    //唯一标识一个定时器--对应连接的文件描述符
    TimeStamp expires;         //时间戳
    TimeoutCallBack cb;        //定时器触发后的回调函数
    bool operator<(const TimerNode& t) {
        return expires < t.expires;
    }
};
```

## 小根堆

```
小根堆是用vector容器实现的。父节点和子节点的索引有关系。
堆：可称为完全二叉树，逻辑上是完全二叉树，物理上是线性结构

如果实现一个小根堆的定时器，实际就是维护一个按树的逻辑存储的定时器节点的顺序队列。

```

### 小根堆操作

```
为了维持小根堆的性质，需要对其进行节点调整，以维护小根堆。。
```

#### ***节点交换

```
是节点调用时常常被调用

之所以节点交换单独作为一个函数。是因为节点交换时，
对应的定时器节点所对应的连接的文件描述符也要进行修改
```

#### 向上调整

```
逻辑上即向上比较。
与其父节点进行比较，如果小于父节点，就与父节点进行交换
并以交换后的节点为当前节点，继续迭代向上比较
```

#### 向下调整

```
逻辑上即向下比较。
与其左右子节点进行比较，如果小于子节点，就与其进行交换
并以交换后的节点为当前节点，继续迭代向下比较
```

## 定时器类

```
为了方便管理所有定时器，应该设置一个专门的类对定时器进行管理
在添加一个新连接的时候就为其添加定时器

数据成员：
为了方便调整，建立一个连接的fd和对应的小根堆中定时器的索引节点

函数成员：
添加定时器  add
删除定时器
清空
更新定时器   just (当在超时时间内)
```

### 添加定时器  add

```
应用场景：在新连接到来之后，为新连接设置超时时间，一定时间没操作就关闭连接。
因为将关闭连接的函数作为回调函数
```

![image-20210709214027388](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210709214027388.png)

```
以上语句的分析：
1.首先判断当前文件描述符对应的定时器是不是存在 
2.如果不存在，就新建一个索引为当前容量大小的定时器节点，将索引节点和文件描述符建立映射
3.使用{}构造定时器节点结构体，存到小根堆里，结构体依次为，{文件描述符、超时时间、回调函数}
4.因为当前是最下层节点，向上更新
```

### 更新定时器

```
应用场景：当超时时间内，有新的读写事件，就更新超时事件
```

```
void HeapTimer::adjust(int id, int timeout) {     /* 调整指定id的结点 */
    assert(!heap_.empty() && ref_.count(id) > 0);
    //将文件描述符对应的定时器的过期时间延长timeout
    heap_[ref_[id]].expires = Clock::now() + MS(timeout);
    //时间延长后将来其下调整
    siftdown_(ref_[id], heap_.size());
}
```

### 获取最近的超时时间--GetNextTick

```
应用场景：当新的一轮eventloop循环，获得最近的超时时间，作为epoll_wait的阻塞等待时间，即防止cpu空转，又不耽误定时器时间的处理。
```

```


int HeapTimer::GetNextTick() {
    tick();          //首先处理超时定时器
    size_t res = -1;
    if(!heap_.empty()) {
        //获得堆顶（对顶即最小值）
        res = std::chrono::duration_cast<MS>(heap_.front().expires-Clock::now()).count();
        if(res < 0) { res = 0; }
    }
    return res;
}
```

### 处理超时定时器（并执行回调事件）

### 清空定时器

### 

