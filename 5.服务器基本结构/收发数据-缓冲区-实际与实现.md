```
先使用IO复用函数判断读写事件再收发数据
通过与客户端连接对应的文件描述符来收取从客户端发来的数据
```

### 收取数据

```
对于epoll，可读事件的标志是EPOLLIN
触发时，调用recv从文件描述符收取数据，将数据放入接受缓冲区，然后做解包处理
```

### 发数据

```
除了ET
其他的模式都不会注册监听可写事件
因为不会因为TCP窗口太少导致本段send和write函数无法写成功的问题

如果注册监听可写事件，会一直触发。
所以在需要发送时都直接使用send或者write发送
所以一般再检测到有问题导致无法发送时，才会注册可写事件
```

### 发数据时ET和LT模式的区别

```
首次发送不注册为可写事件，当出现问题时（TCP窗口太小等）
使用LT注册一次些事件，多次有效，如果数据一次不能发送完，也不用再注册

而ET如果一次发送不了，会给予再次发送数据的机会，也就是重新注册写事件
会设置一个最大发送次数，
```

```
下图ET模式下，传输未完成，仍然设置可写。
在httpcoon的wirte函数
```

![image-20210708201025823](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708201025823.png)

### 多个线程利用同一个socket收/发数据

```
会破坏数据的有序性

和多线程上传下载文件的区别
多线程时将文件按大小分成不同的内容块，然后开启连接
```

### 发送/接受缓冲区

```
发送缓冲区：TCP窗口太小，而待发送的数据太多时，先将数据存储，再等soncket可写时再发送

接受缓冲区：
网络通信层应该与业务层解耦
协议大小的不确定性，应该将数据先缓存，等足够一个包大小再处理
即时收到完整的包，为了业务逻辑的需要，应该先暂存数据，满足条件再处理
```

```
发送/接受缓冲区都应该时一个内存连续的存储容器。
（也可以时一个存储数据的内存块，使用链表结构）
缓冲区应设置存数据/取数据的接口
```

### 缓冲区容量问题

```
参考vector、string，设置动态增加的结构
对于接受缓冲区，寻找特殊标志，设置预留空间，例如存储元数据信息
读写指针为双指针
```

![image-20210708111259706](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708111259706.png)

```
写数据时出现的问题
1.当右侧存储的容量大于当前的需要放入的数据的大小，直接放入
2.当右侧存储的容量小于当前的需要放入的数据的大小
2.1先将读写指针整体向左移动
2.2如果空间还不够，就扩容
```

```
每一个连接都会有一个读缓冲区和一个写缓冲区
缓冲区容量的限制，每个发送/接收缓冲区的初始容量都不会设置的很大
```

### 发送数据对端不接受的问题

```
服务器向对端发送数据时，如果对端一直不接受数据，一段时间后由于窗口太小，
待发送数据再发送缓冲区积压太久，不做任何处理，就会导致内存耗尽

综上，
1.应该为连接的发送缓冲区设置上限
2.为每次发送设置定时器，如果超时还有未发出去的数据，认为该路连接出现问题。
```

### 缓冲区设计实例

```
首先对外提供了读数据和写数据的接口（函数）
```

![image-20210708154428773](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708154428773.png)

```

```

```
在表示客户端和服务器端连接的httpcoon类中，都有一个接受缓冲区和发送缓冲区
```

![image-20210708155501532](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708155501532.png)

```
缓冲区类中的成员函数大致可以分成三类：
1.获取基本的缓冲区的信息
2.作为写缓冲区，及其实现扩容的技术
3.作为读缓冲区保存数据
```

#### 1.基本的缓冲区的信息

```
基本的数据成员有
1.代表缓冲区的vector数据结构   初始时1024个char字符的大小  即1024个字节   即1KB
2.接受缓冲区
3.发送缓冲区

相关的函数成员有获取缓冲区数据结构的
缓冲区首地址
读数据起始位置
写数据起始位置
可读数据的大小
可写数据的大小
前置空闲内存的大小
```

![image-20210708111259706](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708111259706.png)



![image-20210708162557700](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708162557700.png)

#### 2.作为接收请求（读）缓冲区（需要先把数据读入，再供httpconn解析）

```
作为读缓冲区主要用在httprequest类
request类的核心函数就是解析parse函数，其操作对象就是读缓冲区
httprequest是httpcoon的成员类
其主要操作是从读缓冲区解析数据，因为是ET模式。所以需要一次读取全部的数据

成员类：
Readfd函数          在连接的读事件触发时，会调用缓冲区的该函数去读取
RetrieveUntil 函数  在解析的过程中,每当解析一行，就在读缓冲区中更新读指针
```

##### Readfd函数

```
Redfd函数
返回的时新数据的大小
1.设置备用缓冲区buff 如果当前读缓冲区大小不够，就存到备用缓冲区 
2.设置iovec数组，包含两个iovec结构体。第一个是读缓冲区，第二个是备用缓冲区，然后开始readv读数据
3.根据readv返回的数据判断
  3.1返回值小于0 表示错误
  3.2新到的数据小于读缓冲区的备用数据   更新写指针即可
  3.3新到的数据大于读缓冲区的备用数据  append操作
```

![image-20210708164922685](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708164922685.png)

##### append操作

```
实现了3个操作
1.将数据从备用缓冲区存到读缓冲区
  1.1如果前部空闲区域+后部区域大于len,则调用copy函数移到前部
  1.2如果仍然小于，则扩容
2.如果调用append操作，则需要将数据全部前移
3.更新写指针

以下分别为append函数和扩容操作
```

![image-20210708170115606](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708170115606.png)

![image-20210708170146818](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708170146818.png)

##### 解析请求的过程中实时更新写指针

```
--状态机解析请求的过程中每解析一行
--写缓冲区右移-- buff.RetrieveUntil(lineEnd + 2);
--底层还是调用-- Retrieve
```

#### 作为发送响应（写）缓冲区的操作

```
1.是httpresponse类的主要的操作对象。
httpresponse的主要的功能就是构造响应MakeResponse
主要的操作对象就是写缓冲区
2.构造好响应之后
调用writeFd发送到内核
（实际是在httpcoon的wprocess函数实现的）
3.发送之后，清空缓冲区
```

![image-20210708172755441](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708172755441.png)

##### 1.存放响应体.append操作

```
对于主要的构造请求头/请求行/请求体的操作
都是通过缓冲区的append函数进行操作
```

![image-20210708173813626](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708173813626.png)

```
如果存入的数据过大，依旧和做些读缓冲区时一样
```

![image-20210708173941701](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210708173941701.png)

##### 2.发送响应到内核WriteFd

```
1.调用write函数发送
2.判断是否发送成功
  2.1发送成功就更新读指针
  2.2发送失败就保存错误码

实际实现：
1.在httpcoon的process里边实现分发，iov中两端数据分别是响应头+响应体&要发送的html的文件
2.具体的发送在httpcoon的write函数里边
```

```
因为是分两块区域的，一块是
```

##### 3.清空缓冲区

