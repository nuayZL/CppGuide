### 饿汉和懒汉的区别

https://blog.csdn.net/cjbct/article/details/79266057

https://blog.csdn.net/u010419467/article/details/48785589

```
左边是饿汉，在即类产生的时候就创建好实例对象，这是一种空间换时间的方式。
```

![image-20210711181026582](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210711181026582.png)

### 饿汉式

```
饿汉式的单例模式原理很简单，也很好写，并且线程安全，不需要考虑线程同步。。
```

### 懒汉式（C++常用）

```
在第一次调用getInstance()的时候，才创建实例对象。

static CSingleton myInstance;
原先在成员函数外
```

![image-20210711195347820](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210711195347820.png)

### 懒汉式的线程安全问题

```
当调用getInstance()函数时，如果对象还没产生（第一种状态），就需要产生对象，然后返回对象指针。如果对象已经存在了（第二种状态），就直接返回对象指针。当单线程时，没有问题。

多线程情况下，如果一个函数中不同状态有不同操作，就要考虑线程同步的问题了。
所以在第一次创建对象时，需要加锁。
```

![image-20210711195538724](C:\Users\Echo\AppData\Roaming\Typora\typora-user-images\image-20210711195538724.png)

### 优点

```
1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例
2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。
3.提供了对唯一实例的受控访问。
5.允许可变数目的实例。
6.避免对共享资源的多重占用。

```

### 应用场景

```
1.web服务器的日志
2.windows的任务管理器
3.web应用配置对象的读取
4.windows的任务管理器
5.线程池
```

