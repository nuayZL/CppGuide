```
整型变量是最简单的资源类型
```

## 为什么整形变量赋值不是原子操作

```
常见的三种整型变量操作分析
1.整型变量赋确定的值
一般是原子操作，对应一条计算机指令
Cpu将立即数1搬运到变量a的内存地址
可能被编译器优化，实际指令指令中存在的可能性较低
2.变量自身增减  a++
编译得到三条汇编指令(对应三步骤) 
mov eax, dword ptr [a]     //将变量a的内存之搬运到寄存器
inc eax                    //寄存器的值自增
mov dword ptr [a], eax     //寄存器的值搬运回原内存

场景：两个线程都执行自增操作
如果先后各自执行 则不会发生错误
由于：操作系统线程调度的不确定性，线程1执行1，2步骤后。
线程2执行1，2，3.此时最终的结果就是1

3.变量间的赋值
由于CPU体系架构的限制，数据不能从一个变量搬运到另一个变量。必须借助寄存器中转
会翻译成如下的汇编指令
mov eax , dword ptr [b]     
mov dword ptr [a] , eax
即然是两条指令  就有可能在执行完1后被剥夺时间片， 切换到另一个线程而出现不确定情况

```

## C++11对整形变量原子操作的支持

```
提供了了对整型变 原子操作的相关库 ，即 std:atomic 这是一个模板类型:
template<class T> 
struct atomic;    //我们可以传入具体的整形类型对模板实例化
stl库提供了这些实例化的模板类型

有了C++语言本身对原子变量的支持后，就方便写出跨平台的代码
```

跨平台会出现的问题

```
std : :atomic<int> value=99;
运行该代码会调用拷贝构造函数
编译器g++遵循了atomic的拷贝构造函数默认使用=delete标记

所以编译会产生编译错误
应该使用赋值运算符操作函数
```

